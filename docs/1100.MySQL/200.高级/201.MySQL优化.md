---
title: MySQL优化
date: 2021-01-19 21:54:51
permalink: /pages/bdd5dc/
categories:
  - MySQL
  - 基础
tags:
  - 
---



# MySQL 优化

## 表的优化

### 定长和变长分离

如 id int，占4个字节，char(4) 占4个字符长度，也是定长。即每一单元值占的字节是固定的。查询时就非常快。

所以推荐核心且常用的字段，指定定长且放在一张表中

而varchar，text，blob 这种变长字段，适合单放一张表，用主键和核心表关联起来



### 常用字段和不常用字段分离

结合具体业务分析，分析字段的**查询**场景，将查询频率低的字段，单拆出来





### 冗余字段—反范式

第三范式：略。拆分越细，则查询时关联的表越多。

一对多时，需要关联统计的字段上，添加冗余字段

如 BBS 中每个**板块**的**帖子数目**



## 列类型选择



### 字段类型优先级

字段类型优先级：**整形 > date，time 等 > enum，char > varchar > blob，text**

#### 整形

定长，没有国家、地区之分，没有字符集的差异。比如 tinyint 1,2,3,4,5 <--> char(1) a,b,c,d,e。从空间上都是占用1个字节，但是 order by 排序，整形快。而后者需要考虑字符集与校对集（排序规则）

#### time等

定长，运算快，节省空间。但是考虑时区写sql 时不方便，where create_time > '2021-1-1'。可以**考虑用时间戳**。xaprb 大佬博客中说明了关于 data/time 的选择，直接使用 int unsigned not null，存储 UTC 的 Unix 时间戳（最大值问题会解决的）

时间类型存储的选择，参考[xaprb 大佬的博客](https://www.xaprb.com/blog/2014/01/30/timestamps-in-mysql)

#### enum

能起约束值的目的

**内部用整形来存储**

enum 列与 enum 列相关联速度最快，但是与 char 联查时，内部要经历字符串与值的转化

#### char

定长，需要考虑字符集与校对集（排序规则）

如存储性别，以 UTF-8 为例。char(1)，占3个字节；enum('男','女')，内部转成数字来存，多一个转化过程；tinyint，定长1个字节

#### varchar

不定长，需要考虑字符集与校对集（排序规则），速度慢

#### text、blob

**无法使用内存临时表**，排序等操作只能使用外部排序（磁盘上进行）



### 够用就行

大的字段浪费内存，影响速度。

以年龄为例，tinyint unsigned not null 可以存储255岁，足够了，用 int 则浪费了3个字节

varchar(10), varchar(300)若存储的内存相同，但是在联表查询时需要花费更多内存



### 避免存 NULL

NULL 不利于索引，需要特殊的字节来标注，在磁盘中占据的空间更大。但是MySQL5.7已对 NULL 做了改进，占用大小区别不大了。仅查询不便了（where a != null 不行，只能 where a is not null）









## 索引类型

### BTree 索引

指数爆炸的反向

2^n-1，当n=32时，大致为42亿，而此时使用 BTree 可以最多查询 32 次即可查找到（二分查找思想）！

![image-20210119225518969](../images/image-20210119225518969.png)



优点：

*   提高查询速度
*   提高排序速度（中序排列）
*   提高分组速度（先安装 group by 字段排序，然后分组，所以间接提高分组速度）



### Hash 索引

在 memory 表里，默认是 hash 索引，hash 的理论查询时间复杂度为O(1)。

既然hash索引查找如此高效，为什么不都用 hash 索引？

*   hash 函数计算的**结果是随机**的，如果是在磁盘上放置数据，比如主键为 id 的列，那么随着 id 的增长，id 对应的行在**磁盘上随机放置**。
*   此时**无法对范围查询进行优化**，只能精准查询快
*   此时**无法利用前缀索引**。比如在 BTree 中，field 列的值 'helloworld'，并加索引，查询 xx=helloworld，自然可以利用索引，xx=hello也可以利用索引（最左前缀索引）。但是hash('helloword')和hash('hello')两者的关系仍为随机。
*   此时**排序也无法优化**
*   **必须回行**，就是说通过索引拿到数据位置，必须回到表中取数据
*   hash冲突（这个也不会影响太多）。拉链算法，红黑树





## BTree 常见误区—在 where 条件常用列都加索引

例如，where cat_id = 3 and price > 100，查询第3个栏目，100元以上的商品。

误：在cat_id 和 price 上都加上索引。

原因：只能用上 cat_id 或 price 的索引，因为是**独立的索引，同时只能用上1个**

解决：实际中，建立联合索引。将多个列整体看作一个





## BTree 常见误区—多列索引—左前缀—顺序

例如：在多列上建立联合索引，查询哪个列，索引都将发挥作用？

误：多列索引上，索引是否发挥作用，需要**满足最左前缀要求**

以 index(a,b,c) 为例，**注意和顺序有关**！

| 语句                                          | 索引是否发挥作用                  |
| --------------------------------------------- | --------------------------------- |
| where a = 3                                   | 是，只使用了 a 列                 |
| where a = 3 and b = 5                         | 是，使用了 a，b列                 |
| where a = 3 and b = 5 and c = 4               | 是，使用了 a，b，c列              |
| where a = 3 or where c = 4                    | 否                                |
| where a = 3 and  c = 4                        | a列使用了索引，c未使用            |
| where a = 3 and b >5 and c = 4                | a列使用了索引，b使用了，c不能使用 |
| 同上, where a = 3 and b like 'xxx%' and c = 7 | a列使用了索引，b使用了，c不能使用 |

为便于理解，假设 abc 为各10米长的木板（**顺序**），河面宽30米，精确匹配，则走10米，like左前缀及返回查询，则走5米。走不到的木板即无法使用索引



## 面试题

### 联合索引练习

假设某个表有一个联合索引(c1,c2,c3,c4)，以下哪些能使用该联合索引的 c1,c2,c3 部分

```sql
CREATE TABLE tt(
c1 TINYINT NOT NULL DEFAULT 0,
c2 TINYINT NOT NULL DEFAULT 0,
c3 TINYINT NOT NULL DEFAULT 0,
c4 TINYINT NOT NULL DEFAULT 0,
c5 TINYINT NOT NULL DEFAULT 0,
index c1234(c1,c2,c3,c4)
);

INSERT INTO tt VALUES(1,3,5,6,7),(2,3,9,8,3),(4,3,2,7,5);
```

```sql
EXPLAIN SELECT * FROM tt where c1 = 1 and c2 = 1 and c4 > 1 and c3 = 1;

+--+-----------+-----+----------+-----+-------------+-----+-------+----+----+--------+---------------------+
|id|select_type|table|partitions|type |possible_keys|key  |key_len|ref |rows|filtered|Extra                |
+--+-----------+-----+----------+-----+-------------+-----+-------+----+----+--------+---------------------+
|1 |SIMPLE     |tt   |NULL      |range|c1234        |c1234|4      |NULL|1   |100     |Using index condition|
+--+-----------+-----+----------+-----+-------------+-----+-------+----+----+--------+---------------------+
and 同级，MySQL 自动重排优化。所以 c1,c2,c3,c4都能使用到。 key_len表示查询用到索引长度，建表时tinyint占用1字节，联合索引总占用4个字节
```

```sql
EXPLAIN SELECT * FROM tt where c1 = 1 and c2 = 1 and c4 = 1 order by c3;

+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+---------------------+
|id|select_type|table|partitions|type|possible_keys|key  |key_len|ref        |rows|filtered|Extra                |
+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+---------------------+
|1 |SIMPLE     |tt   |NULL      |ref |c1234        |c1234|2      |const,const|1   |33.33   |Using index condition|
+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+---------------------+
c1,c2可以用到，c3用在排序上。c4无法使用
```

```sql
-- C: where c1 = x and c4 = x group by c3,c2
EXPLAIN SELECT count(*) FROM tt where c1 = 1 and c4 = 1 group by c3,c2;

+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------------------------------------+
|id|select_type|table|partitions|type|possible_keys|key  |key_len|ref  |rows|filtered|Extra                                    |
+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------------------------------------+
|1 |SIMPLE     |tt   |NULL      |ref |c1234        |c1234|1      |const|1   |33.33   |Using where; Using index; Using temporary|
+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------------------------------------+

c1可以用到，c4无法使用，c3,c2顺序不同，无法使用
```

```sql
-- D: where c1 = ? and c5 = ? group by c2,c3
EXPLAIN SELECT count(*) FROM tt where c1 = 1 and c5 = 1 group by c2,c3;

+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------+
|id|select_type|table|partitions|type|possible_keys|key  |key_len|ref  |rows|filtered|Extra      |
+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------+
|1 |SIMPLE     |tt   |NULL      |ref |c1234        |c1234|1      |const|1   |33.33   |Using where|
+--+-----------+-----+----------+----+-------------+-----+-------+-----+----+--------+-----------+

c1可以用到，c2,c3用到分组上。c5无法使用
```

```sql
-- E: where c1 = ? and c2 = ? and c5 = ? order by c2,c3
EXPLAIN SELECT count(*) FROM tt where c1 = 1 and c2 = 1 and c5 = 1 order by c2,c3;

+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+-----------+
|id|select_type|table|partitions|type|possible_keys|key  |key_len|ref        |rows|filtered|Extra      |
+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+-----------+
|1 |SIMPLE     |tt   |NULL      |ref |c1234        |c1234|2      |const,const|1   |33.33   |Using where|
+--+-----------+-----+----------+----+-------------+-----+-------+-----------+----+--------+-----------+
c1,c2查询用到，c3排序用到，c2排序（没有必要了，已经=查询了，优化掉了），c5无法使用
```



### 场景题

有商品表，有主键、goods_id、栏目列 cat_id、价格 price。已经在 price 上架了索引，但安装价格查询还是很慢，可能是什么原因？怎么解决？

在实际场景中，电商网站的商品分类很多，直接在所有商品中按照价格查询商品是极少的，一般客户都是来到某个分类下再查。

所以可以去掉单独的 price 索引，加(cat_id,price) 联合索引。

如果根据日志分析许多人这样查：电脑->某品牌->价格，那么可以加(cat_id,brand_id,price)联合索引





## 聚簇索引 & 非聚簇索引

区别

*   Innodb 的**主索引文件上（主键索引），直接存放该行数据**，称为聚簇索引。**次索引指向对主键的引用（否则每个索引都要存储该行数据，炸了都）**；

    查询不指定排序时默认按照主键排序（主索引中有数据）

*   **MyISAM 索引是非聚簇索引，主索引和次索引都指向物理行（磁盘位置），所以查询需要回行！**

    因为索引和数据分为2个文件，数据在 xxx.myd，索引在 xxx.myi，当然还有其他文件如表信息文件xxx.frm；

    查询不指定排序时是乱序，因为按照磁盘存放的顺序读取

注意（InnoDB来说）：

*   主键索引既存储索引值，又在叶子汇总存储行的数据
*   如果没有主键，则会将 unique key 做主键
*   如果没有 unique，则系统生成一个内部的 rowid 做主键

聚簇索引优缺点：

*   优势：**根据主键查询条目比较少时，不用回行**（数据就在主键节点下）
*   劣势：如果碰到**不规则数据插入**时，造成频繁的**页分裂（树重排）**。但是对于**内存、固态硬盘来说，有随机读写功能**，页分裂差异不明显；而硬盘盘片需要转圈读取





## 索引覆盖

