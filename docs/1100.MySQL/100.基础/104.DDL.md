---
title: DDL
date: 2021-01-08 00:26:28
permalink: /pages/9cf90b/
categories:
  - MySQL
  - 基础
tags:
  -
---

# DDL

**DDL 无需 commit**

## DDL—数据库

### 查看所有数据库 🔥

```
mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.01 sec)

mysql>
```

### 创建数据库 🔥

```
CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHARSET=UTF8];
```

```
mysql> CREATE DATABASE IF NOT EXISTS demo;
Query OK, 1 row affected, 1 warning (0.00 sec)

mysql>
```

### 切换当前数据库 🔥

对于每一个连接到`MySQL`服务器的客户端，都有一个`当前数据库`的概念（也可以称之为`默认数据库`），我们创建的表默认都会被放到当前数据库中

```
USE 数据库名;
```

在介绍表的基本操作之前，我们应该把当前数据库切换到刚刚创建的数据库`demo`上：

```
mysql> USE demo;
Database changed
mysql>
```

看到显示了`Database changed`说明当前数据库已经切换成功了。需要注意的是，在退出当前客户端之后，也就是你输入了`exit`或者`quit`命令之后或者直接把当前的黑框框页面关掉，当你再次调用`mysql -h 主机名 -u 用户名 -p密码`的时候，相当于重新开启了一个客户端，需要重新调用`USE 数据库名称`的语句来选择一下当前数据库。

其实我们在新启动客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，只要把数据库名称写在启动客户端的命令`mysql -h 主机名 -u 用户名 -p密码`后边就好，如下：

```
mysql -h localhost -u root -p123456 demo
```

### 删除数据库 🔥

```
DROP DATABASE [IF EXISTS] 数据库名;
```

```
mysql> DROP DATABASE IF EXISTS demo;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql>
```

### 查看数据库定义信息

包括创建语句和字符集

```
SHOW CREATE DATABASE 数据库名;
```

### 修改数据库编码

```
ALTER DATABASE 数据库名 CHARACTER  SET UTF8;
```

### 查看当前使用的数据库，MySQL 特有

```
SELECT DATABASE();
```

## DDL—表

### 展示当前数据库中的表 🔥

```
SHOW TABLES;
```

当前数据库是`demo`，然后用上述语句查看下`demo`数据库中都有哪些表：

```
mysql> SHOW TABLES;
Empty set (0.00 sec)

mysql>
```

### 创建表 🔥

#### 语法

```sql
 CREATE TABLE [IF NOT EXISTS] 表名 (
     列名1    数据类型    [列的属性],
     列名2    数据类型    [列的属性],
     ...
     列名n    数据类型    [列的属性],
     PRIMARY KEY (列名)
 ) COMMENT '表的注释信息';

-- 约束可以在定义列的时候进行设置，也可以在语句的末尾进行设置。但是NOT NULL约束只能以列为单位进行设置
```

- 在`CREATE TABLE`后写清楚我们要创建的表的名称。
- 然后在小括号`()`中定义上这个表的各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性（列的属性用中括号`[]`引起来的意思就是这部分是可选的，也就是可有可无的）。
- 列名、数据类型、列的属性之间用空白字符分开就好，然后各个列的信息之间用逗号`,`分隔开。
- 如果创建一个已经存在的表的话是会报错的，可以加入`IF NOT EXISTS`语句

#### 示例

```
mysql> CREATE TABLE first_table (
    ->     first_column INT,
    ->     second_column VARCHAR(100)
    -> ) COMMENT '第一个表';
Query OK, 0 rows affected (0.02 sec)

mysql>
```

输出`Query OK, 0 rows affected (0.02 sec)`意味着创建成功了，并且耗时 0.02 秒。

有了创建`first_table`的经验，我们就可以着手用`MySQL`把之前提到的学生基本信息表和成绩表给创建出来了，先把学生基本信息表搬下来看看：

**学生基本信息表**

| 学号     | 姓名   | 性别 | 身份证号           | 学院       | 专业             | 入学时间 |
| -------- | ------ | ---- | ------------------ | ---------- | ---------------- | -------- |
| 20180101 | 杜子腾 | 男   | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018/9/1 |
| 20180102 | 杜琦燕 | 女   | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018/9/1 |
| 20180103 | 范统   | 男   | 17156319980116959X | 计算机学院 | 软件工程         | 2018/9/1 |
| 20180104 | 史珍香 | 女   | 141992199701078600 | 计算机学院 | 软件工程         | 2018/9/1 |

很显然，这个表有`学号`、`姓名`、`性别`、`身份证号`、`学院`、`专业`、`入学时间`这几个列，其中的`学号`是整数类型的，`入学时间`是日期类型的，由于身份证号是固定的 18 位，我们可以把`身份证号`这一列定义成固定长度的字符串类型，`性别`一列只能填`男`或`女`，所以我们这里把它定义为`ENUM`类型的，其余各个列都是变长的字符串类型。看一下创建学生基本信息表的语句：

```sql
CREATE TABLE student_info (
    number INT,
    name VARCHAR(5),
    sex ENUM('男', '女'),
    id_number CHAR(18),
    department VARCHAR(30),
    major VARCHAR(30),
    enrollment_time DATE
) COMMENT '学生基本信息表';
```

然后再看一下学生成绩表：

| 学号     | 科目               | 成绩 |
| -------- | ------------------ | ---- |
| 20180101 | 母猪的产后护理     | 78   |
| 20180101 | 论萨达姆的战争准备 | 88   |
| 20180102 | 母猪的产后护理     | 100  |
| 20180102 | 论萨达姆的战争准备 | 98   |
| 20180103 | 母猪的产后护理     | 59   |
| 20180103 | 论萨达姆的战争准备 | 61   |
| 20180104 | 母猪的产后护理     | 55   |
| 20180104 | 论萨达姆的战争准备 | 46   |

这个表有`学号`、`科目`、`成绩`这几个列，`学号`和`成绩`是整数类型的，科目是字符串类型的，所以我们可以这样写建表语句：

```sql
CREATE TABLE student_score (
    number INT,
    subject VARCHAR(30),
    score TINYINT
) COMMENT '学生成绩表';
```

待这几个表创建成功之后，我们使用`SHOW TABLES`语句看一下当前数据库中有哪些表：

```
mysql> SHOW TABLES;
+---------------------+
| Tables_in_demo |
+---------------------+
| first_table         |
| student_info        |
| student_score       |
+---------------------+
3 rows in set (0.01 sec)

mysql>
```

```sql
DROP TABLE IF EXISTS `player`;
CREATE TABLE `player`  (
    `player_id` int(11) NOT NULL AUTO_INCREMENT,
    `team_id` int(11) NOT NULL,
    `player_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
    `height` float(3, 2) NULL DEFAULT 0.00,
    PRIMARY KEY (`player_id`) USING BTREE,
    UNIQUE INDEX `player_name`(`player_name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
-- 其中 player_name 字段的字符集是 utf8（推荐utf-8mb4），排序规则是 utf8_general_ci，代表对大小写不敏感，如果设置为utf8_bin，代表对大小写敏感，还有许多其他排序规则这里不进行介绍。
```

### 删除表 🔥

```
DROP TABLE [IF EXISTS] 表1, 表2, ..., 表n;
```

```
mysql> DROP TABLE first_table;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW TABLES;
+---------------------+
| Tables_in_demo |
+---------------------+
| student_info        |
| student_score       |
+---------------------+
2 rows in set (0.00 sec)

mysql>
```

如果我们尝试删除某个不存在的表的话会报错，可以加入`IF EXISTS`语句

### 查看表结构 🔥

```
DESCRIBE 表名;
DESC 表名;
EXPLAIN 表名;
SHOW COLUMNS FROM 表名;
SHOW FIELDS FROM 表名;
```

比如我们看一下`student_info`这个表的结构：

```
mysql> DESC student_info;
+-----------------+-------------------+------+-----+---------+-------+
| Field           | Type              | Null | Key | Default | Extra |
+-----------------+-------------------+------+-----+---------+-------+
| number          | int(11)           | YES  |     | NULL    |       |
| name            | varchar(5)        | YES  |     | NULL    |       |
| sex             | enum('男','女')   | YES  |     | NULL    |       |
| id_number       | char(18)          | YES  |     | NULL    |       |
| department      | varchar(30)       | YES  |     | NULL    |       |
| major           | varchar(30)       | YES  |     | NULL    |       |
| enrollment_time | date              | YES  |     | NULL    |       |
+-----------------+-------------------+------+-----+---------+-------+
7 rows in set (0.00 sec)

mysql>
```

可以看到，这个`student_info`表的各个列的名称、类型和属性就都展示出来了。

### 查看表的定义信息 🔥

```
SHOW CREATE TABLE 表名;
```

比如：

```
mysql> SHOW CREATE TABLE student_info;
+--------------+------------------------------------------+
| Table        | Create Table
+--------------+------------------------------------------+
| student_info | CREATE TABLE `student_info` (
  `number` int(11) DEFAULT NULL,
  `name` varchar(5) DEFAULT NULL,
  `sex` enum('男','女') DEFAULT NULL,
  `id_number` char(18) DEFAULT NULL,
  `department` varchar(30) DEFAULT NULL,
  `major` varchar(30) DEFAULT NULL,
  `enrollment_time` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='学生基本信息表'          |
+--------------+-------------------------------------------+
1 row in set (0.00 sec)

mysql>
```

由于这行数据太长了，所以输出效果并不是很好，我们可以把原来用于标记语句结束的分号`;`改为`\G`，以垂直的方式展示每一列数据的效果可能好点：

```
mysql> SHOW CREATE TABLE student_info\G
*************************** 1. row ***************************
       Table: student_info
Create Table: CREATE TABLE `student_info` (
  `number` int(11) DEFAULT NULL,
  `name` varchar(5) DEFAULT NULL,
  `sex` enum('男','女') DEFAULT NULL,
  `id_number` char(18) DEFAULT NULL,
  `department` varchar(30) DEFAULT NULL,
  `major` varchar(30) DEFAULT NULL,
  `enrollment_time` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='学生基本信息表'
1 row in set (0.00 sec)

mysql>
```

可以看到，使用`SHOW CREATE TABLE`这个语句展示出来的表结构就是我们平时创建表的语句

### 没有选择当前数据库时对表的操作 🔥

有时候我们并没有使用`USE`语句来选择当前数据库，或者在一条语句中遇到的表分散在不同的数据库中，如果我们想在语句中使用这些表，那么就必须显式的指定这些表所属的数据库了。比如不管当前数据库是不是`demo`，我们都可以调用这个语句来展示数据库`demo`里边的表：

```
mysql> SHOW TABLES FROM demo;
+---------------------+
| Tables_in_demo |
+---------------------+
| first_table         |
| student_info        |
| student_score       |
+---------------------+
3 rows in set (0.00 sec)

mysql>
```

其他地方如果使用到表名的话，需要显式指定这个表所属的数据库，指明方式是这样的：

```sql
数据库名.表名
```

比方说我们想查看`demo`数据库下`first_table`表的结构，但是又没有使用`USE demo`语句指定当前数据库，此时可以这样写语句：

```
SHOW CREATE TABLE demo.first_table\G
```

### 修改表名 🔥

1.  方式一：

    ```
    ALTER TABLE 旧表名 RENAME TO 新表名;
    ```

    我们把`first_table`表的名称修改为`first_table1`（当前数据库为`demo`）：

    ```
    mysql> ALTER TABLE first_table RENAME TO first_table1;
    Query OK, 0 rows affected (0.01 sec)

    mysql> SHOW TABLES;
    +---------------------+
    | Tables_in_xiaohaizi |
    +---------------------+
    | first_table1        |
    | student_info        |
    | student_score       |
    +---------------------+
    3 rows in set (0.00 sec)

    mysql>
    ```

    通过`SHOW TABLES`命令可以看到已经改名成功了。

2.  方式二：

    ```
    RENAME TABLE 旧表名1 TO 新表名1, 旧表名2 TO 新表名2, ... 旧表名n TO 新表名n;
    ```

    这种改名方式的牛逼之处就是它可以在一条语句中修改多个表的名称。这里就不举例了，自己测试一下吧。

如果在修改表名的时候指定了数据库名，还可以将该表转移到对应的数据库下，比方说我们先再创建一个数据库`demo2`：

```
mysql> CREATE DATABASE demo2;
Query OK, 1 row affected (0.00 sec)

mysql>
```

然后把`first_table1`表转移到这个`demo2`数据库下：

```
mysql> ALTER TABLE first_table1 RENAME TO demo2.first_table1;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW TABLES FROM demo2;
+-------------------+
| Tables_in_demo2 |
+-------------------+
| first_table1      |
+-------------------+
1 row in set (0.00 sec)

mysql> SHOW TABLES FROM demo;
+---------------------+
| Tables_in_demo |
+---------------------+
| student_info        |
| student_score       |
+---------------------+
2 rows in set (0.00 sec)

mysql>
```

可以看到`first_table1`就从数据库`demo`转移到`demo2`里边了。我们再用修改表名的方式二再把该表转移到`demo`数据库中，并且将其更名为`first_table`：

```
mysql> RENAME TABLE demo2.first_table1 TO demo.first_table;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

### 复制表结构 🔥

```
CREATE TABLE 表名 LIKE 被复制的表名;
```

### 修改表的字符集 🔥

```
ALTER TABLE 表名 CHARACTER  SET UTF8;
```

## DDL—列

### 增加列 🔥

#### 语法

我们可以使用下边的语句来增加表中的列：

```sql
ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];
```

```sql
ALTER TABLE 表名 ADD /*COLUMN*/(
  列名 列类型 该列所需约束,
    列名 列类型 该列所需约束,
  ...
);
-- MySQL、Oracle、SQL Server中可以不用写COLUMN，PostgreSQL需写上
```

比如我们向`first_table`里添加一个名叫`third_column`的列就可以这么写：

```
mysql> ALTER TABLE first_table ADD COLUMN third_column CHAR(4) ;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE first_table\G
*************************** 1. row ***************************
       Table: first_table
Create Table: CREATE TABLE `first_table` (
  `first_column` int(11) DEFAULT NULL,
  `second_column` varchar(100) DEFAULT NULL,
  `third_column` char(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
1 row in set (0.01 sec)

mysql>
```

通过查看表的结构可以看到`third_column`列已经添加成功了。

#### 增加列到特定位置

默认的情况下列都是加到现有列的最后一列后面，我们也可以在添加列的时候指定它的位置，常用的方式如下：

- 添加到第一列：

  ```
  ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] FIRST;
  ```

  让我们把`fourth_column`插入到第一列：

  ```
  mysql> ALTER TABLE first_table ADD COLUMN fourth_column CHAR(4) FIRST;
  Query OK, 0 rows affected (0.04 sec)
  Records: 0  Duplicates: 0  Warnings: 0

  mysql> SHOW CREATE TABLE first_table\G
  *************************** 1. row ***************************
     Table: first_table
  Create Table: CREATE TABLE `first_table` (
  `fourth_column` char(4) DEFAULT NULL,
  `first_column` int(11) DEFAULT NULL,
  `second_column` varchar(100) DEFAULT NULL,
  `third_column` char(4) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
  1 row in set (0.01 sec)

  mysql>
  ```

  看到插入成功了。

- 添加到指定列的后边：

  ```
  ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] AFTER 指定列名;
  ```

  再插入一个`fifth_column`到`first_column`后边瞅瞅：

  ```
  mysql> ALTER TABLE first_table ADD COLUMN fifth_column CHAR(4) AFTER first_column;
  Query OK, 0 rows affected (0.03 sec)
  Records: 0  Duplicates: 0  Warnings: 0

  mysql> SHOW CREATE TABLE first_table\G
  *************************** 1. row ***************************
         Table: first_table
  Create Table: CREATE TABLE `first_table` (
    `fourth_column` char(4) DEFAULT NULL,
    `first_column` int(11) DEFAULT NULL,
    `fifth_column` char(4) DEFAULT NULL,
    `second_column` varchar(100) DEFAULT NULL,
    `third_column` char(4) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
  1 row in set (0.00 sec)

  mysql>
  ```

  可以看到`fifth_column`列就被插到`first_column`列后边了。

### 删除列 🔥

```sql
ALTER TABLE 表名 DROP /*COLUMN*/ 列名;
-- MySQL、Oracle可以用 (列名，列名...)来删除多个列
-- MySQL、Oracle、SQL Server中可以不用写COLUMN，PostgreSQL需写上
```

我们把刚才向`first_table`里添加几个列都删掉试试：

```
mysql> ALTER TABLE first_table DROP COLUMN third_column;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE first_table DROP COLUMN fourth_column;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> ALTER TABLE first_table DROP COLUMN fifth_column;
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE first_table\G
*************************** 1. row ***************************
       Table: first_table
Create Table: CREATE TABLE `first_table` (
  `first_column` int(11) DEFAULT NULL,
  `second_column` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
1 row in set (0.00 sec)

mysql>
```

从结果中可以看出`third_column`、`fourth_column`、`fifth_column`这几个列都被删除了。

### 修改列信息 🔥

#### 修改列的信息

- 方式一：

  ```
  ALTER TABLE 表名 MODIFY 列名 新数据类型 [新属性];
  ```

  我们来修改一下`first_table`表的`second_column`列，把它的数据类型修改为`VARCHAR(2)`：

  ```
  mysql> ALTER TABLE first_table MODIFY second_column VARCHAR(2);
  Query OK, 0 rows affected (0.04 sec)
  Records: 0  Duplicates: 0  Warnings: 0

  mysql> SHOW CREATE TABLE first_table\G
  *************************** 1. row ***************************
         Table: first_table
  Create Table: CREATE TABLE `first_table` (
    `first_column` int(11) DEFAULT NULL,
    `second_column` varchar(2) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
  1 row in set (0.00 sec)

  mysql>
  ```

  可以看到`second_column`的数据类型就已经被修改为`VARCHAR(2)`了。不过在修改列信息的时候需要注意：**修改后的数据类型和属性一定要兼容表中现有的数据**！比方说原先`first_table`表的类型是`VARCHAR(100)`，该类型最多能存储 100 个字符，如果表中的某条记录的`second_column`列值为`'aaa'`，也就是占用了 3 个字符，而此时我们尝试使用上边的语句将`second_column`列的数据类型修改为`VARCHAR(2)`，那么此时就会报错，因为`VARCHAR(2)`并不能存储 3 个字符。

- 方式二：

  ```
  ALTER TABLE 表名 CHANGE 旧列名 新列名 新数据类型 [新属性];
  ```

  可以看到这种修改方式需要我们填两个列名，也就是说在修改数据类型和属性的同时也可以修改列名！比如我们修改`second_column`的列名为`second_column1`：

  ```
  mysql> ALTER TABLE first_table CHANGE second_column second_column1 VARCHAR(2)\G
  Query OK, 0 rows affected (0.04 sec)
  Records: 0  Duplicates: 0  Warnings: 0

  mysql> SHOW CREATE TABLE first_table\G
  *************************** 1. row ***************************
         Table: first_table
  Create Table: CREATE TABLE `first_table` (
    `first_column` int(11) DEFAULT NULL,
    `second_column1` varchar(2) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
  1 row in set (0.00 sec)

  mysql>
  ```

  可以看到结果中`second_column`的列名已经被修改为了`second_column1`，不过我们并没有改动该列的数据类型和属性，所以直接把旧的数据类型和属性抄过来就好了。不过在修改列信息的时候需要注意：**修改后的数据类型和属性一定要兼容表中现有的数据**！

- 方式三（仅修改列名）

  ```sql
  ALTER TABLE player RENAME COLUMN age to player_age -- RENAME也可以
  ```

#### 修改列排列位置

如果我们觉得当前列的顺序有问题的话，可以使用下边这几条语句进行修改：

1.  将列设为表的第一列：

    ```
    ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 FIRST;
    ```

    先看一下现在表`first_table`的各个列的排列顺序：

    ```
    mysql> SHOW CREATE TABLE first_table\G
    *************************** 1. row ***************************
           Table: first_table
    Create Table: CREATE TABLE `first_table` (
      `first_column` int(11) DEFAULT NULL,
      `second_column1` varchar(2) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
    1 row in set (0.00 sec)

    mysql>
    ```

    可以看到，列的顺序依次是：`first_column`、`second_column1`。现在我们想把`second_column`放在第一列可以这么写：

    ```
    mysql> ALTER TABLE first_table MODIFY second_column1 VARCHAR(2) FIRST;
    Query OK, 0 rows affected (0.02 sec)
    Records: 0  Duplicates: 0  Warnings: 0

    mysql> SHOW CREATE TABLE first_table\G
    *************************** 1. row ***************************
           Table: first_table
    Create Table: CREATE TABLE `first_table` (
      `second_column1` varchar(2) DEFAULT NULL,
      `first_column` int(11) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
    1 row in set (0.00 sec)

    mysql>
    ```

    看到`second_column1`已经成为第一列了！

2.  将列放到指定列的后边：

    ```
    ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 AFTER 指定列名;
    ```

    比方说我们想把`second_column1`再放到`first_column`后边可以这么写：

    ```
    mysql> ALTER TABLE first_table MODIFY second_column1 VARCHAR(2) AFTER first_column;
    Query OK, 0 rows affected (0.03 sec)
    Records: 0  Duplicates: 0  Warnings: 0

    mysql> SHOW CREATE TABLE first_table\G
    *************************** 1. row ***************************
           Table: first_table
    Create Table: CREATE TABLE `first_table` (
      `first_column` int(11) DEFAULT NULL,
      `second_column1` varchar(2) DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='第一个表'
    1 row in set (0.00 sec)

    mysql>
    ```

### 一条语句中包含多个修改操作 🔥

如果对同一个表有多个修改操作的话，我们可以把它们放到一条语句中执行，就像这样：

```
ALTER TABLE 表名 操作1, 操作2, ..., 操作n;
```

上边我们在演示删除列操作的时候用三条语句连着删了`third_column`、`fourth_column`和`fifth_column`这三个列，其实这三条语句可以合并为一条：

```
ALTER TABLE first_table DROP COLUMN third_column, DROP COLUMN fourth_column, DROP COLUMN fifth_column;
```

这样人敲的语句也少了，服务器也不用分多次执行从而效率也高了，何乐而不为呢？
