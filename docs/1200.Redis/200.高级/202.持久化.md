---
title: 持久化
date: 2021-03-22 10:41:04
permalink: /pages/49af26/
categories:
  - Redis
  - 高级
tags:
  - 
---
# 持久化

## 简介

### 什么是持久化？

利用**永久性**存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。

### 为什么要持久化？

**防止**数据的意外**丢失**，确保数据**安全性**

### 持久化过程**保存什么**

*   将当前**数据状态**进行保存，**快照**形式，存储数据结果，存储格式简单，关注点在**数据**。RDB
*   将数据的**操作过程**进行保存，**日志**形式，存储操作过程，存储格式复杂，关注点在数据的操作**过程**。AOF

![img](../images/20200608142523.png)



## RDB

### RDB 配置 🔥

-   dbfilename dump.rdb

    -   说明：设置本地数据库**文件名**，默认值为 dump.rdb
    -   经验：通常设置为`dump-端口号.rdb`

-   dir

    -   说明：设置存储.rdb文件的**路径**
    -   经验：通常设置成存储空间较大的目录中，目录名称**data**

-   rdbcompression yes

    -   说明：设置存储至本地数据库时是否**压缩数据**，默认为 **yes**，采用 LZF 压缩
    -   经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）

-   rdbchecksum yes

    -   说明：设置是否**进行RDB文件格式校验**，该校验过程在**写文件和读文件过程均进行**
    -   经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%**时间消耗**，但是存储一定的数据损坏风险

-   stop-writes-on-bgsave-error yes

    -   说明：[bgsave相关]。后台存储过程中如果**出现错误**现象，是否**停止保存**操作 
    -   经验：通常默认为开启状态

-   save second changes

    -   作用：满足**限定时间范围内key的变化数量达到指定数量**即进行持久化

    *   参数
        *   second：监控时间范围，秒！
        *   changes：监控 key 的**变化**量

常见配置如下：

```
protected-mode no
# bind 127.0.0.1
port 6379
daemonize yes
logfile "/usr/local/redis-6.2.1/logs/redis-6379.log"
dir ./data
dbfilename dump-6379.rdb
rdbcompression yes
rdbchecksum yes
stop-writes-on-bgsave-error yes
save 300 5
```







### RDB 启动方式—save 指令

**手动执行**一次保存操作



### save 工作原理 🔥

![img](../images/20200608142541.png)

注意：**save指令**的执行会**阻塞**当前Redis服务器，直到当前RDB过程完成为止，有可能会造成**长时间阻塞**，线上**不建议使用**。





### 数据量大、单线程阻塞问题？

那么**数据量过大，单线程执行方式造成效率过低如何处理**?

可以采用**后台执行**（见 bgsave）：

*   谁：Redis操作者**（用户）发起指令**；Redis **服务器控制指令执行**
*   什么时间：**即时（发起）**；**合理的时间（执行）**
*   干什么事情：保存数据





### RDB 启动方式—bgsave 指令 🔥

**手动启动后台保存**操作，但不是立即执行



### bgsave 工作原理 🔥

![image-20210322224952967](../images/image-20210322224952967.png)

注意：bgsave命令是针对save阻塞问题做的优化。Redis 内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃。

**bgsave的保存操作可以通过redis的日志查看**。并且执行时就已经返回 background...



### 何时执行保存指令问题？

**反复执行保存指令，忘记了怎么办**？不知道数据产生了多少变化，**何时保存**？

自动执行

*   谁：Redis**服务器发起指令（基于条件）**
*   什么时间：**满足条件**

*   干什么事情：保存数据



### RDB 启动方式—save 配置 🔥

```
save second changes
```

*   作用：满足**限定时间范围内key的变化数量达到指定数量**即进行持久化

*   参数

    *   second：监控时间范围，秒！
    *   changes：监控 key 的**变化**量

*   位置：在conf文件中进行配置

    ```
    save 900 1 
    save 300 10 
    save 60 10000
    ```





### save 配置原理 🔥

![image-20210322231343462](../images/image-20210322231343462.png)

注意：

*   save配置要**根据实际业务情况进行设置**，频度过高或过低都会出现性能问题，结果可能是**灾难性**的
*   save配置中对于second与changes设置通常具有**互补对应关系**（一大一小），尽量不要设置成包含性关系
*   save配置启动后执行的是**bgsave**操作





### RDB三种启动方式对比

| 方式           | save 指令 | bgsave 指令 |
| -------------- | --------- | ----------- |
| 读写           | 同步      | 异步        |
| 阻塞客户端指令 | 是        | 否          |
| 额外内存消耗   | 否        | 是          |
| 启动新进程     | 否        | 是          |



### RDB 特殊启动方式 🔥

*   全量复制：在**主从复制**中详细讲解

*   服务器**运行过程中重启**

    ```
    debug reload
    ```

*   **关闭服务器时指定保存数据**

    ```
    shutdown save
    ```

    **默认**情况下执行 shutdown 命令时，**自动执行 bgsave（如果没有开启AOF持久化功能）**



### RDB 优缺点 🔥

优点：

*   RDB是一个**紧凑压缩**的二进制文件，**存储效率较高**
*   RDB内部存储的是Redis在某个时间点的**数据快照**，非常适合用于**数据备份**，**全量复制**等场景
*   **RDB恢复数据的速度要比AOF快很多**
*   应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于**灾难恢复**。



缺点：

*   RDB方式无论是执行指令还是利用配置，**无法做到实时持久化**，具有较大的**可能性丢失数据**
*   bgsave指令每次运行要执行**fork操作创建子进程**，要**牺牲掉一些性能**
*   **存储数据量大时，效率低**。因为是"全量"数据
*   Redis的众多版本中**未进行RDB文件格式的版本统一**，有可能出现各版本服务之间数据格式无法**兼容**现象





## AOF

### RDB 缺点如何解决

缺点：

*   存储数据量较大，效率较低。基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低
*   所以大数据量下的IO性能较低
*   基于fork创建子进程，内存产生额外消耗
*   宕机带来的数据丢失风险

解决思路：

*   不写全数据，仅记录**部分数据**
*   降低区分数据**是否改变**的难度，改记录数据为**记录操作过程**
*   对**所有操作均进行记录**，**排除丢失数据**的风险



### AOF 概念

*   **AOF（append only file）持久化**：以**独立日志**的方式**记录每次写命令**，**重启时再重新执行AOF文件中命令**达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为**记录数据产生的过程**
*   AOF的主要作用是**解决了数据持久化的实时性**，目前已经是Redis持久化的**主流方式**



### AOF写数据过程 & 三种策略 appendfsync 🔥

![image-20210322233538723](../images/image-20210322233538723.png)

*   **always**（每次）：每次写入操作均同步到AOF文件中，**数据零误差，性能较低**
*   **everysec🔥**（每秒）：**默认**。每秒将缓冲区中的指令同步到AOF文件中，**数据准确性较高，性能较高**。在系统突然宕机的情况下**丢失1秒内**的数据
*   **no**（系统控制）：由**操作系统控制**每次同步到AOF文件的周期，整体过程**不可控**



### AOF 配置 🔥

```
appendonly yes|no
```

作用：是否开启AOF持久化功能，**默认为不开启状态**

```
appendfsync always|everysec|no
```

作用：AOF写数据策略

```
appendfilename filename
```

作用：AOF**持久化文件名**，默认文件名未appendonly.aof，建议配置为`appendonly-端口号.aof`

```
dir
```

作用：AOF持久化文件保存路径，与RDB持久化文件保持一致即可



常见配置如下：

```
protected-mode no
# bind 127.0.0.1
port 6379
daemonize yes
logfile "/usr/local/redis-6.2.1/logs/redis-6379.log"
dir ./data
dbfilename dump-6379.rdb
rdbcompression yes
rdbchecksum yes
stop-writes-on-bgsave-error yes
save 60 2
appendonly yes
appendfsync everysec
appendfilename appendonly-6379.aof
```





### AOF 重写 🔥

如果连续执行如下指令该如何处理

![image-20210322235031635](../images/image-20210322235031635.png)

随着命令不断写入AOF，**文件会越来越大**，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是**将Redis进程内的数据转化为写命令同步到新AOF文件的过程**。简单说就是**将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录**。

AOF重写作用：

*   降低磁盘占用量，提高磁盘利用率
*   提高持久化效率，降低持久化写时间，提高IO性能
*   降低数据恢复用时，提高数据恢复效率



### AOF重写规则

*   进程内**已超时的数据不再写入**文件

*   **忽略无效指令**，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令

    如 del key1、 hdel key2、srem key3、set key4 111、set key4 222等

*   **对同一数据的多条写命令合并为一条命令**
    如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为:lpush list1 a b c。 为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素





### AOF 重写方式—bgrewriteaof 指令🔥

*   手动重写

    ```
    bgrewriteaof
    ```



### bgrewriteaof 指令工作原理

![image-20210322235807544](../images/image-20210322235807544.png)



### AOF 重写方式—配置 🔥

自动重写触发条件设置

```
auto-aof-rewrite-min-size size 
auto-aof-rewrite-percentage percentage
```

自动重写触发比对参数（执行 `info`指令，查看 Persistence获取具体信息）

```
aof_current_size 
aof_base_size # 这个应该会变化吧
```

自动重写触发条件

![image-20210323000007405](../images/image-20210323000007405.png)





### AOF 工作流程 🔥

![image-20210323000635512](../images/image-20210323000635512.png)



### AOF 重写流程 🔥

![image-20210323000657592](../images/image-20210323000657592.png)

![image-20210323000804799](../images/image-20210323000804799.png)





### RDB与AOF区别与选择 🔥

| 持久化方式   | RDB                    | AOF                 |
| ------------ | ---------------------- | ------------------- |
| 占用存储空间 | 小（数据级：压缩）     | 大（指令级：重写）  |
| 存储速度     | 慢（数据量大时非常慢） | 快                  |
| 恢复速度     | 快（直接复制）         | 慢（执行指令）      |
| 数据安全性   | 会丢失数据             | 依据策略决定        |
| 资源消耗     | 高/重量级（文件大）    | 低/轻量级（文件小） |
| 启动优先级   | 低                     | **高**              |

*   对**数据非常敏感**，建议使用默认的**AOF**持久化方案

    -   AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。
    -   注意：由于AOF文件存储体积较大，且恢复速度较慢

*   **数据呈现阶段有效性**，建议使用 **RDB** 持久化方案

*   -   数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案
    -   注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重

*   综合比对：
    *   RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊
    *   如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF
    *   如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB
    *   灾难恢复选用RDB
    *   双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量





## 持久化应用场景

*   ~~Tips 1:redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性~~。数据库读最大值+1
*   ~~Tips 3:redis应用于各种结构型和非结构型高热度数据访问加速~~。数据库也存了
*   ~~Tips 4:redis 应用于购物车数据存储设计~~。数据库也存了
*   Tips 5:redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计
*   Tips 6:redis 应用于具有操作先后顺序的数据控制
*   Tips 7:redis 应用于最新消息展示
*   ~~Tips 9:redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索~~
*   Tips 12:redis 应用于基于黑名单（数据库不一定有）与白名单（数据库肯定有）设定的服务控制
*   Tips 13:redis 应用于计数器组合排序功能对应的排名
*   ~~Tips 15:redis 应用于即时任务/消息队列执行管理~~。MQ
*   ~~Tips 16:redis 应用于按次结算的服务控制~~

不同**库**（不是那16个db）里不同持久化方式！