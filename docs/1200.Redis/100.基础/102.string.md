---
title: string
date: 2021-02-24 22:48:08
permalink: /pages/e5dc7e/
categories:
  - Redis
  - 基础
tags:
  - 
---

# string

## 介绍

*   存储的数据：单个数据，最简单的数据存储类型，也是**最常用**的数据存储类型
*   存储数据的格式：**一个存储空间保存一个数据**
*   存储内容：通常使用字符串，**如果字符串以整数的形式展示，可以作为数字操作使用**，但本质还是字符串！



## set

**添加、修改**命令：`set key value`

```
127.0.0.1:6379> set name conan
OK

127.0.0.1:6379> set name conanan
OK
```



## get

查询命令：`get key`

查询一个存在的key：

```
127.0.0.1:6379> get name
"conanan"
```

查询一个不存在的key：

```
127.0.0.1:6379> get age
(nil)
```



## del

删除命令：`del key [key ...]`

删除一个存在的key，返回影响的数量1：

```
127.0.0.1:6379> del name
(integer) 1
```

删除一个不存在的key，返回影响的数量0：

```
127.0.0.1:6379> del name
(integer) 0
```

删除多个

```
127.0.0.1:6379> set name a
OK
127.0.0.1:6379> set age 1
OK
127.0.0.1:6379> del name age
(integer) 2
```





## mset

添加、修改多个数据：`mset key1 value1 key2 value2 ...`

其中`m`为 mutiple 多个意思

```bash
127.0.0.1:6379> mset a 1 b 2 c 3
OK
```



## mget

获取多个数据：`mget key1 key2 ...`

```bash
127.0.0.1:6379> mget a b c d
1) "1"
2) "2"
3) "3"
4) (nil) --注意这里
-- 注意整个返回的格式
```



## strlen

获取数据字符个数（字符串长度）：`strlen key`

```bash
127.0.0.1:6379> get name
"conanan"
127.0.0.1:6379> strlen name
(integer) 7
127.0.0.1:6379>
```

注意中文：

```bash
127.0.0.1:6379> set c_name 哈哈
OK
127.0.0.1:6379> get c_name
"\xe5\x93\x88\xe5\x93\x88"
127.0.0.1:6379> strlen c_name
(integer) 6
```



## append

**追加**信息到原始信息后部（如果**原始信息存在就追加，否则新建**）：`append key value`

注意：**返回的是追加完毕后的长度**！

```bash
127.0.0.1:6379> set name conanan
OK
127.0.0.1:6379> append name ' and lan'
(integer) 15
127.0.0.1:6379> get name
"conanan and lan"
```





## set 和 mset 对比

单数据操作与多数据操作的选择之惑

![image-20210224232436229](../images/image-20210224232436229.png)

基本上选择`mset`不会有问题，但是要注意实际数据大小！太少这俩没太大区别；太多太多也不能使用他俩，一条一条处理不行，单线程处理太多数据也不行，应该拆分数据后使用`mset`



## incr / incrby / incrbyfloat

设置数值数据增加指定范围的值（但是值为负数时即是减法操作）

```bash
incr key
incrby key increment 
incrbyfloat key increment
```



## decr / decrby

设置数值数据减少指定范围的值（但是值为负数时即是加法操作）

```bash
decr key
decrby key increment
```





## setex / psetex

设置数据具有指定的生命周期

```bash
setex key seconds value  -- 秒
psetex key milliseconds value -- 毫秒
```

实例

```bash
127.0.0.1:6379> setex tel 3 110
OK
127.0.0.1:6379> get tel
"110"
127.0.0.1:6379> get tel
(nil)
```

但是记住，**再次执行会重置时间**，如：

```bash
127.0.0.1:6379> setex tel 3 110
OK
127.0.0.1:6379> setex tel 60 110 -- 重置为60秒
OK
127.0.0.1:6379> setex tel 110 -- 重置永久
OK
```





## 注意事项

*   数据操作不成功的反馈与数据正常操作之间的差异 
    *   表示运行结果是否成功
        *   (integer) 0 → false 失败
        *   (integer) 1 → true 成功 
    *   表示运行结果值
        *   (integer) 3 → 3 3个
        *   (integer) 1 → 1 1个
*   数据未获取到
    *   (nil)等同于null 
*   数据最大存储量
    *   512MB，也不可能存储这么大的值！
*   数值计算最大范围(java中的long的最大值)
    *   9223372036854775807



## key 的设置约定 🔥

数据库中的热点数据key命名惯例

![image-20210224235138080](../images/image-20210224235138080.png)



## 场景—主页高频访问信息显示控制

例如新浪微博大V主页显示粉丝数与微博数量。解决：

*   在redis中为大V用户设定用户信息，**以用户主键和属性值作为key**，后台设定定时刷新策略即可 
    *   eg: `user:id:3506728370:fans` → 12210947
    *   eg: `user:id:3506728370:blogs` → 6164
    *   eg: `user:id:3506728370:focuss` → 83
*   在redis中**以json格式**存储大V用户信息，定时刷新(也可以**使用hash类型**) 
    *   eg: `user:id:3506728370` → {"id":3506728370,"name":"春晚","fans":12210862,"blogs":6164, "focus":83}



## 场景—分布式数据库主键 ID

大型企业级应用中，分表操作是基本操作，使用多张表存储同类型数据，但是对应的主键 id 必须保证统一性 ，不能重复。Oracle 数据库具有 sequence 设定，可以解决该问题，但是 MySQL数据库并不具有类似的机制，那么如何解决?

可以**利用 string 存储数字类型，并利用 incr 命令来生成主键id**

string 作为数值操作注意：

*   string在redis内部存储默认就是一个字符串，当**遇到增减类操作incr，decr时会转成数值型进行计算**。

*   **redis所有的操作都是原子性的**，采用**单线程**处理所有业务，命令是一个一个执行的，因此**无需考虑并发**

    **带来的数据影响**。

*   注意：按数值进行操作的数据，如果**原始数据不能转成数值**，或**超越了redis 数值上限范围**，将**报错**。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）

结论：

*   **redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性**
*   此方案**适用于所有数据库，且支持数据库集群**





## 场景—数据时效性

业务场景：

*   “最强女生”启动海选投票，只能通过微信投票，每个微信号每 4 小时只能投1票。 
*   电商商家开启热门商品推荐，热门商品不能一直处于热门期，每种商品热门期维持3天，3天后自动取消热门。 
*   新闻网站会出现热点新闻，热点新闻最大的特征是时效性，如何自动控制热点新闻的时效性。

通过 redis `setex` 或`psetex` 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作

