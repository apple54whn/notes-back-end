(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{705:function(e,t,v){"use strict";v.r(t);var _=v(11),s=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("元素"),v("strong",[e._v("无序")]),e._v("（存储时不是按照类似数组索引顺序添加）、"),v("strong",[e._v("唯一")]),e._v("。底层都是对应的"),v("code",[e._v("*Map")]),e._v("。由于没有索引，只可以通过"),v("code",[e._v("Iterator")]),e._v("或"),v("code",[e._v("foreach")]),e._v("。与"),v("code",[e._v("Collection")]),e._v("接口的方法一致，"),v("code",[e._v("Set")]),e._v(" 的实现类都重写了"),v("code",[e._v("toString()")]),e._v("方法。")])]),e._v(" "),v("li",[v("p",[e._v("使用Set集合保存"),v("strong",[e._v("自定义对象（可为 null）")]),e._v("。带有"),v("code",[e._v("Hash*")]),e._v("的"),v("strong",[e._v("必须重写")]),v("code",[e._v("hashCode()")]),e._v("和"),v("code",[e._v("equal()")]),e._v("方法，且重写的俩方法尽可能保持"),v("strong",[e._v("一致性")]),e._v("（即相等的对象必须有相同的 hashCode ，不相等亦如此）")]),e._v(" "),v("p",[e._v("​")])])]),e._v(" "),v("h2",{attrs:{id:"hashset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashset"}},[e._v("#")]),e._v(" HashSet")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("底层数据结构是"),v("strong",[e._v("哈希表（元素为链表或红黑树的数组）")]),e._v("，实际上是一个"),v("code",[e._v("HashMap")]),e._v("实例（value 存储静态的 Object），查询快。"),v("strong",[e._v("根据"),v("code",[e._v("hashCode")]),e._v("决定元素的存放位置")]),e._v("，但"),v("strong",[e._v("迭代出的元素顺序和存入顺序不一定一致")]),e._v("，即"),v("strong",[e._v("不稳定")]),e._v("（hash重排）。")])]),e._v(" "),v("li",[v("p",[e._v("初始容量为16，当如果使用率超过0.75，(16*0.75=12) 就会扩大容量为原来的2倍（16扩容为32，依次为64,128....等）")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("添加元素过程")]),e._v("（以 HashSet 为例）")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("向"),v("code",[e._v("HashSet")]),e._v("中添加元素"),v("code",[e._v("a")]),e._v("，首先调用元素"),v("code",[e._v("a")]),e._v("所在类的"),v("code",[e._v("hashCode()")]),e._v("方法，计算元素"),v("code",[e._v("a")]),e._v("的"),v("code",[e._v("hashCode")]),e._v("。")])]),e._v(" "),v("li",[v("p",[e._v("此"),v("code",[e._v("hashCode")]),e._v("值接着通过某种散列函数（如：取模。这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布， 该散列函数设计的越好 ）计算出在"),v("code",[e._v("HashSet")]),e._v("底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：")]),e._v(" "),v("ul",[v("li",[e._v("如果此位置上没有其他元素，则元素"),v("code",[e._v("a")]),e._v("添加成功。 ——>情况1")]),e._v(" "),v("li",[e._v("如果此位置上有其他元素"),v("code",[e._v("b")]),e._v("（或以链表或红黑树形式存在的多个元素），则比较元素"),v("code",[e._v("a")]),e._v("与元素"),v("code",[e._v("b")]),e._v("的"),v("code",[e._v("hashCode")]),e._v("值：\n"),v("ul",[v("li",[e._v("如果"),v("code",[e._v("hashCode")]),e._v("值不相同，则元素"),v("code",[e._v("a")]),e._v("添加成功。——>情况2")]),e._v(" "),v("li",[e._v("如果"),v("code",[e._v("hashCode")]),e._v("值相同，进而需要调用元素"),v("code",[e._v("a")]),e._v("所在类的"),v("code",[e._v("equals()")]),e._v("方法：\n"),v("ul",[v("li",[v("code",[e._v("equals()")]),e._v("返回"),v("code",[e._v("true")]),e._v(",元素"),v("code",[e._v("a")]),e._v("添加失败")]),e._v(" "),v("li",[v("code",[e._v("equals()")]),e._v("返回"),v("code",[e._v("false")]),e._v(",则元素"),v("code",[e._v("a")]),e._v("添加成功。——>情况3")])])])])])])]),e._v(" "),v("li",[v("p",[e._v("对于添加成功的情况2和情况3而言：元素"),v("code",[e._v("a")]),e._v("与已经存在指定索引位置上数据以"),v("strong",[e._v("链表或红黑树")]),e._v("的方式存储。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("JDK7：元素"),v("code",[e._v("a")]),e._v("放到数组中，指向原来的元素。")])]),e._v(" "),v("li",[v("p",[e._v("JDK8：原来的元素在数组中，指向元素"),v("code",[e._v("a")])]),e._v(" "),v("p",[e._v("总结：七上八下")])])])])])])]),e._v(" "),v("h2",{attrs:{id:"linkedhashset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashset"}},[e._v("#")]),e._v(" LinkedHashSet")]),e._v(" "),v("ul",[v("li",[e._v("继承"),v("code",[e._v("HashSet")]),e._v("，底层数据结构是"),v("strong",[e._v("双向链表和哈希表（元素为链表或红黑树的数组），元素迭代顺序和存入顺序一致")])]),e._v(" "),v("li",[v("code",[e._v("LinkedHashSet")]),v("strong",[e._v("插入性能略低")]),e._v("于 "),v("code",[e._v("HashSet")]),e._v("，但在"),v("strong",[e._v("迭代访问")]),e._v(" "),v("code",[e._v("Set")]),e._v(" 里的"),v("strong",[e._v("全部元素")]),e._v("时"),v("strong",[e._v("有很好的性能")]),e._v("。")])]),e._v(" "),v("h2",{attrs:{id:"treeset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#treeset"}},[e._v("#")]),e._v(" TreeSet")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("底层数据结构是"),v("strong",[e._v("红黑树（自平衡二叉树），有序，查询速度比"),v("code",[e._v("List")]),e._v("快 "),v("strong",[e._v("，实际上是一个 "),v("code",[e._v("TreeMap")]),e._v("实例。使用"),v("code",[e._v("TreeSet")]),e._v("保存自定义元素，这个元素")]),e._v("必须实现"),v("code",[e._v("Comparable")]),e._v("接口")]),e._v("或构造时"),v("strong",[e._v("必须提供"),v("code",[e._v("Comparator")]),e._v("实现类")])]),e._v(" "),v("ul",[v("li",[e._v("元素唯一性通过红黑树存储时确定，相同元素丢弃， "),v("strong",[e._v("根据"),v("code",[e._v("compareTo")]),e._v("返回值是否是0来决定")])]),e._v(" "),v("li",[e._v("元素的顺序通过红黑树存储，并通过"),v("strong",[e._v("中（根）序遍历展示")])])])]),e._v(" "),v("li",[v("p",[e._v("新增的方法如下：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Comparator comparator()")])]),e._v(" "),v("li",[v("code",[e._v("Object first()")])]),e._v(" "),v("li",[v("code",[e._v("Object last()")])]),e._v(" "),v("li",[v("code",[e._v("Object lower(Object e)")])]),e._v(" "),v("li",[v("code",[e._v("Object higher(Object e)")])]),e._v(" "),v("li",[v("code",[e._v("SortedSet subSet(fromElement, toElement)")])]),e._v(" "),v("li",[v("code",[e._v("SortedSet headSet(toElement)")])]),e._v(" "),v("li",[v("code",[e._v("SortedSet tailSet(fromElement)")])])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("保证元素的排列方式：")])]),e._v(" "),v("ol",[v("li",[v("p",[v("strong",[e._v("自然排序（元素具备比较性）")]),e._v("：让元素所属的类实现"),v("code",[e._v("Comparable")]),e._v("接口，重写"),v("code",[e._v("compareTo")])]),e._v(" "),v("p",[e._v("向 TreeSet 中添加元素时，只有第一个元素无须比较"),v("code",[e._v("compareTo()")]),e._v("方法，后面添加的所有元素都会调用"),v("code",[e._v("compareTo()")]),e._v("方法进行比较。且重写该对象对应的 "),v("code",[e._v("equals()")]),e._v(" 方法时，应保证该方法与 "),v("code",[e._v("compareTo(Object obj)")]),e._v(" 方法有一致的结果")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("比较器排序（集合具备比较性）")]),e._v("：让集合构造方法接收"),v("code",[e._v("Comparator")]),e._v("接口的实现类对象，重写"),v("code",[e._v("compare")])]),e._v(" "),v("p",[e._v("向 TreeSet 中添加元素时，只有第一个元素无须比较"),v("code",[e._v("compare()")]),e._v("方法，后面添加的所有元素都会调用"),v("code",[e._v("compare()")]),e._v("方法进行比较。且重写该对象对应的 "),v("code",[e._v("equals()")]),e._v(" 方法时，应保证该方法与 "),v("code",[e._v("compare()")]),e._v(" 方法有一致的结果")]),e._v(" "),v("p",[v("strong",[e._v("s1-s2升序，s2-s1降序")])]),e._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Lambda")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("TreeSet")]),v("span",{pre:!0,attrs:{class:"token generics"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Person")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" people "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("TreeSet")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Comparator")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("comparingInt")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Person")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("getAge")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("thenComparing")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Person")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("getName")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("reversed")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" \n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br")])])])])])]),e._v(" "),v("h2",{attrs:{id:"list-与-set-之间转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list-与-set-之间转换"}},[e._v("#")]),e._v(" List 与 Set 之间转换")]),e._v(" "),v("ul",[v("li",[e._v("都可以在构造时传递对方")]),e._v(" "),v("li",[e._v("都继承了 Collection 的 addAll（以整体添加，但每个都是独立的）、add（当成单独元素）")])])])}),[],!1,null,null,null);t.default=s.exports}}]);