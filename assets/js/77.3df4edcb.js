(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{686:function(e,t,r){"use strict";r.r(t);var v=r(11),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_17-test"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_17-test"}},[e._v("#")]),e._v(" 17 Test")]),e._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#测试分类"}},[e._v("测试分类")])]),r("li",[r("a",{attrs:{href:"#junit4"}},[e._v("Junit4")])]),r("li",[r("a",{attrs:{href:"#junit5"}},[e._v("Junit5")]),r("ul",[r("li",[r("a",{attrs:{href:"#beforeall"}},[e._v("@BeforeAll")])]),r("li",[r("a",{attrs:{href:"#afterall"}},[e._v("@AfterAll")])]),r("li",[r("a",{attrs:{href:"#beforeeach"}},[e._v("@BeforeEach")])]),r("li",[r("a",{attrs:{href:"#aftereach"}},[e._v("@AfterEach")])])])])])]),r("p"),e._v(" "),r("h2",{attrs:{id:"测试分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#测试分类"}},[e._v("#")]),e._v(" 测试分类")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("黑盒测试")]),e._v("：不需要写代码，给输入值，看程序是否能够输出期望的值。")]),e._v(" "),r("li",[r("strong",[e._v("白盒测试")]),e._v("："),r("strong",[e._v("需要写代码")]),e._v("的，关注"),r("strong",[e._v("程序具体的执行流程")]),e._v("。如 Junit。")])]),e._v(" "),r("h2",{attrs:{id:"junit4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#junit4"}},[e._v("#")]),e._v(" Junit4")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("定义一个测试类(测试用例)")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("测试类名：被测试的类名+Test")])]),e._v(" "),r("li",[r("p",[e._v("包名：xxx.xxx.xx.test")])])])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("定义测试方法：可以独立运行")])]),e._v(" "),r("p",[r("strong",[e._v("方法名")]),e._v("："),r("strong",[e._v("test+测试的方法名")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("返回值")]),e._v("："),r("strong",[e._v("void")])]),e._v(" "),r("li",[r("strong",[e._v("参数列表")]),e._v("："),r("strong",[e._v("空参")])])])]),e._v(" "),r("li",[r("p",[e._v("给方法加**@Test**")])]),e._v(" "),r("li",[r("p",[e._v("导入"),r("strong",[e._v("junit依赖环境")]),e._v("，"),r("code",[e._v("org.junit")])])])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("判定结果：")]),e._v(" "),r("ul",[r("li",[r("p",[r("strong",[e._v("红色")]),e._v("：失败")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("绿色")]),e._v("：成功")])]),e._v(" "),r("li",[r("p",[e._v("一般我们会使用"),r("strong",[e._v("断言")]),e._v("操作来处理结果")]),e._v(" "),r("ul",[r("li",[r("strong",[r("code",[e._v("Assert.assertEquals(expected 期望的结果,actual 运算的结果);")])]),e._v("，支持各种类型数据")])])]),e._v(" "),r("li",[r("p",[e._v("补充：以下方法无论测试成功与否都会执行")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("@Before")]),e._v(":\n"),r("ul",[r("li",[e._v("修饰的方法会在"),r("strong",[e._v("测试方法之前被自动执行")]),e._v("，用于资源申请"),r("code",[e._v("init")])])])]),e._v(" "),r("li",[r("strong",[e._v("@After")]),e._v(":\n"),r("ul",[r("li",[e._v("修饰的方法会在"),r("strong",[e._v("测试方法执行之后自动被执行")]),e._v("，用于释放资源"),r("code",[e._v("close")])])])])])])])])]),e._v(" "),r("h2",{attrs:{id:"junit5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#junit5"}},[e._v("#")]),e._v(" Junit5")]),e._v(" "),r("blockquote",[r("p",[e._v("org.junit.jupiter，SpringBoot 2.2后默认导入")])]),e._v(" "),r("h3",{attrs:{id:"beforeall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforeall"}},[e._v("#")]),e._v(" "),r("code",[e._v("@BeforeAll")])]),e._v(" "),r("ul",[r("li",[e._v("@BeforeAll用于表示已注释的方法应在当前测试类中的所有测试之后执行。")]),e._v(" "),r("li",[e._v("与@BeforeEach方法相反，@BeforeAll方法对于给定的测试类仅执行一次。")]),e._v(" "),r("li",[e._v("@BeforeAll方法必须具有void返回类型，不能为私有，并且默认情况下必须为静态。因此，除非使用@TestInstance（Lifecycle.PER_CLASS）注释测试类，否则@Nested测试类或接口默认方法不支持@BeforeAll方法。")]),e._v(" "),r("li",[e._v("@BeforeAll方法可以选择声明要由ParameterResolvers解析的参数。")])]),e._v(" "),r("h3",{attrs:{id:"afterall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#afterall"}},[e._v("#")]),e._v(" "),r("code",[e._v("@AfterAll")])]),e._v(" "),r("ul",[r("li",[e._v("@AfterAll用于表示已注释的方法应在当前测试类中的所有测试之后执行。")]),e._v(" "),r("li",[e._v("与@AfterEach方法相反，@AfterAll方法对于给定的测试类仅执行一次。")]),e._v(" "),r("li",[e._v("@AfterAll方法必须具有void返回类型，不能为私有，并且默认情况下必须为"),r("strong",[e._v("静态")]),e._v("。因此，除非使用@TestInstance（Lifecycle.PER_CLASS）注释测试类，否则@Nested测试类或接口默认方法不支持@AfterAll方法。")]),e._v(" "),r("li",[e._v("@AfterAll方法可以选择声明要由ParameterResolvers解析的参数。")])]),e._v(" "),r("h3",{attrs:{id:"beforeeach"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforeeach"}},[e._v("#")]),e._v(" "),r("code",[e._v("@BeforeEach")])]),e._v(" "),r("ul",[r("li",[e._v("@BeforeEach用于表示应在当前测试类中的每个@ Test，@ RepeatedTest，@ ParameterizedTest，@ TestFactory和@TestTemplate方法之前执行带注释的方法。")]),e._v(" "),r("li",[e._v("@BeforeEach方法必须具有void返回类型，不能为私有，并且不能为静态。")]),e._v(" "),r("li",[e._v("它们可以选择声明要由ParameterResolvers解析的参数。")])]),e._v(" "),r("h3",{attrs:{id:"aftereach"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aftereach"}},[e._v("#")]),e._v(" "),r("code",[e._v("@AfterEach")])]),e._v(" "),r("ul",[r("li",[e._v("@AfterEach用于表示应在当前测试类中的每个@ Test，@ RepeatedTest，@ ParameterizedTest，@ TestFactory和@TestTemplate方法之前执行带注释的方法。")]),e._v(" "),r("li",[e._v("@AfterEach方法必须具有void返回类型，不能为私有，并且不能为静态。")]),e._v(" "),r("li",[e._v("它们可以选择声明要由ParameterResolvers解析的参数。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);